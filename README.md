# 一个高效的序列化反序列化库

- [x] 支持json序列化反序列化
- [x] 支持tinybuf([私有协议](https://github.com/xiongziliang/tinybuf/wiki/tinybuf%E5%BA%8F%E5%88%97%E5%8C%96%E5%8D%8F%E8%AE%AE))序列化反序列化
- [x] 纯C代码，适合嵌入式系统
- [x] 序列化反序列化性能高效
- [x] tinybuf序列化格式占用字节更少，更利于传输

# 性能对比(release模式)
- [x] json格式时，序列化性能大约为jsoncpp的3倍
- [x] json格式时，反序列化性能大约为jsoncpp的1.5倍
- [x] tinybuf格式时，序列化性能大约为jsoncpp的10~20倍
- [x] tinybuf格式时，反序列化性能大约为jsoncpp的4倍

# 测试结果截图
![image](https://user-images.githubusercontent.com/11495632/65878363-8076b500-e3c0-11e9-807a-c2ef51efe11c.png)

# 系统支持
1. Windows上首选支持VC
2. Linux使用Gcc测试
# 计划 
1. 完成基本系统
2. 完善oop类型系统 trait系统 函数签名系统 （参数表对象  函数描述子对象 支持参数类型校验）
   1. 添加内置类型的标准注册 如i32 u64等 采用类rust的基本类型命名
   2. 注册所有基本类型的操作函数
   3. 基于异类型box列表类型（复用序列化系统之中的实现）实现参数表
   4. 使用名称+参数表+返回类型构造函数签名对象
   5. 支持使用函数参数表对象校验传递过来的 generic_box_list(异类型box列表 一种内存数据类型 内部包含有类似序列化之后的box序列数据 支持把不同类型的数据组织为一个表 要求不能有任何pointer内容在其中 且不可有容器类型 必须是可以直接原地二进制转换为tinybuf_value对象的box 也就是所谓的数据对象)
   6. 规范oop系统中的方法注册体系 方法注册提供结构化的函数签名信息 对于第一个参数X类型的函数 就可以声明为X类型的成员函数，且支持一个函数attach到不同类型上作为不同类型的成员函数 同时普通函数也可以直接attach到类型上作为静态函数
   7. 重新定义trait的含义：trait是一个协议要求 不负责实现但负责要求目标类型拥有一组函数实现 无论是静态函数还是成员函数，运行时动态校验 一个trait是一个叫trait_req的对象 支持运行时检查是否满足这个trait
   8. 支持使用generic_box_list调用普通函数，通过一些asm技巧 支持不同的调用约定 默认使用cdecl调用约定，
      1. 调用过程：获取到某个指针 拿到一个generic_box_list 还原到一个tinybuf_value对象数组，按顺序对每个value按照其类型进行压栈操作或符合调用协议的asm操作，对于大的二进制对象也要让栈和寄存器状态符合某个调用协议 以实现动态调用
      2. 此功能优先实现 且作为独立功能实现 具体说 
         1. 可以有一个叫bin_value的对象 此对象只有一个数据指针和一个数据长度 单位字节 这个是可以被当作参数压栈的最小单位
         2. 有一个void*指针 现在要实现对这个void指针的调用 运行时动态调用
         3. 此处有一个叫dynamic_call(void*,list of bin_value)的函数
         4. 核心在于实现这个叫dynamic_call的函数 这里假设调用协议只关心二进制数据参数的大小而不关心其实际类型例如一个i32和一个f32的传参方式完全一样 如果不一样 必须做相应处理
         5. 使用dyncall封装实现 通过代理tinybuf_value 为bin_value可实现动态类型与序列化系统兼容


## 语言支持

1. 优先支持Rust 对接纯C接口
2. 支持C++ 支持把C++对象树自动转换为tinybuf_value树 通过subref连接 C++类需要提供静态函数 get_sub_refs()用于返回子引用表