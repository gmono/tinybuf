mod ast;
mod interpreter;
lalrpop_util::lalrpop_mod!(grammar); // generated by build.rs from grammar.lalrpop
pub use interpreter::Interpreter;
pub use interpreter::ensure_oop_demo_registered;
pub use ast::Stmt;

use thiserror::Error;
use regex::Regex;

#[derive(Error, Debug)]
pub enum ScriptError {
    #[error("lex error at byte {0}")]
    LexError(usize),
    #[error("parse error: {0}")]
    ParseError(String),
    #[error("runtime error: {0}")]
    RuntimeError(String),
}

pub fn parse_program(input: &str) -> Result<Vec<Stmt>, ScriptError> {
    let transformed = lower_extended_syntax(input)?;
    grammar::ProgramParser::new()
        .parse(&transformed)
        .map_err(|e| ScriptError::ParseError(format!("{e}")))
}

pub fn interpret_script(input: &str) -> Result<Vec<String>, ScriptError> {
    let transformed = lower_extended_syntax(input)?;
    let ast = grammar::ProgramParser::new()
        .parse(&transformed)
        .map_err(|e| ScriptError::ParseError(format!("{e}")))?;
    let outputs = interpreter::run(&ast).map_err(|e| ScriptError::RuntimeError(e))?;
    Ok(outputs)
}

fn lower_extended_syntax(src: &str) -> Result<String, ScriptError> {
    // 1) Replace a++ with let a=a+1
    let re_inc = Regex::new(r"(?m)\b([a-zA-Z_][a-zA-Z0-9_]*)\s*\+\+\s*([;\n])").unwrap();
    let tmp = re_inc.replace_all(src, "let $1=$1+1$2").to_string();
    // 2) Lower loop extended syntax:
    //    - loop(name=aaa) with { ... } step { ... } for { ... }
    //    - loop with { ... } { ... }   // body without explicit `for`
    //    into: run (#"block",#"loop",(persist=((...)),step=((...)),name="aaa"),(body_items))
    let mut out = String::new();
    let mut i = 0;
    let bytes = tmp.as_bytes();
    while i < bytes.len() {
        if i + 4 <= bytes.len() && &bytes[i..i+4] == b"loop" {
            let mut cursor = i + 4;
            // Optional config: ( ... )
            while cursor < bytes.len() && bytes[cursor].is_ascii_whitespace() { cursor += 1; }
            let mut name_opt: Option<String> = None;
            if cursor < bytes.len() && bytes[cursor] == b'(' {
                // Extract until matching ')'
                let mut depth = 1usize;
                let start = cursor + 1;
                cursor += 1;
                while cursor < bytes.len() && depth > 0 {
                    let c = bytes[cursor] as char;
                    if c == '(' { depth += 1; }
                    else if c == ')' { depth -= 1; }
                    cursor += 1;
                }
                let cfg = &tmp[start..(cursor-1)];
                // Parse simplistic "name=IDENT_OR_STRING"
                if let Some(rest) = cfg.trim().strip_prefix("name=") {
                    let val = rest.trim();
                    let label = if val.starts_with('"') && val.ends_with('"') && val.len() >= 2 {
                        val[1..val.len()-1].to_string()
                    } else {
                        val.to_string()
                    };
                    name_opt = Some(label);
                }
                while cursor < bytes.len() && bytes[cursor].is_ascii_whitespace() { cursor += 1; }
            }
            // Expect "with"
            if cursor + 4 > bytes.len() || &bytes[cursor..cursor+4] != b"with" {
                // Not a loop; emit and advance one char
                out.push(bytes[i] as char);
                i += 1;
                continue;
            }
            cursor += 4;
            while cursor < bytes.len() && bytes[cursor].is_ascii_whitespace() { cursor += 1; }
            if cursor >= bytes.len() || bytes[cursor] != b'{' {
                return Err(ScriptError::ParseError("expected `{` after `loop with`".to_string()));
            }
            // Parse persist block
            let (persist_src, after_persist) = extract_brace_block(&tmp[cursor..])?;
            cursor += after_persist;
            // Optional step block: "step" "{...}"
            while cursor < bytes.len() && bytes[cursor].is_ascii_whitespace() { cursor += 1; }
            let mut step_src_opt: Option<String> = None;
            if cursor + 4 <= bytes.len() && &bytes[cursor..cursor+4] == b"step" {
                cursor += 4;
                while cursor < bytes.len() && bytes[cursor].is_ascii_whitespace() { cursor += 1; }
                if cursor >= bytes.len() || bytes[cursor] != b'{' {
                    return Err(ScriptError::ParseError("expected `{` after `step`".to_string()));
                }
                let (step_src, after_step) = extract_brace_block(&tmp[cursor..])?;
                step_src_opt = Some(step_src);
                cursor += after_step;
            }
            // Optional "for"
            while cursor < bytes.len() && bytes[cursor].is_ascii_whitespace() { cursor += 1; }
            if cursor + 3 <= bytes.len() && &bytes[cursor..cursor+3] == b"for" {
                cursor += 3;
                while cursor < bytes.len() && bytes[cursor].is_ascii_whitespace() { cursor += 1; }
            }
            // Expect body block "{...}"
            if cursor >= bytes.len() || bytes[cursor] != b'{' {
                return Err(ScriptError::ParseError("expected `{` for loop body".to_string()));
            }
            let (body_src, after_body) = extract_brace_block(&tmp[cursor..])?;
            // Recursively lower inner loops before parsing
            let persist_src2 = lower_extended_syntax(&persist_src)?;
            let persist_src3 = {
                let mut s = persist_src2;
                if !s.ends_with('\n') { s.push('\n'); }
                s
            };
            let persist_ast = grammar::ProgramParser::new().parse(&persist_src3)
                .map_err(|e| ScriptError::ParseError(format!("{e}")))?;
            let step_ast = if let Some(step_src) = &step_src_opt {
                let step_src2 = lower_extended_syntax(step_src)?;
                let step_src3 = {
                    let mut s = step_src2;
                    if !s.ends_with('\n') { s.push('\n'); }
                    s
                };
                Some(grammar::ProgramParser::new().parse(&step_src3)
                    .map_err(|e| ScriptError::ParseError(format!("{e}")))?)
            } else { None };
            let body_src2 = lower_extended_syntax(&body_src)?;
            let body_src3 = {
                let mut s = body_src2;
                if !s.ends_with('\n') { s.push('\n'); }
                s
            };
            let body_ast = grammar::ProgramParser::new().parse(&body_src3)
                .map_err(|e| ScriptError::ParseError(format!("{e}")))?;
            // Render lists
            let persist_lists = persist_ast.iter()
                .map(|s| render_expr(&interpreter::stmt_to_list_expr(s)))
                .collect::<Vec<_>>()
                .join(",");
            let step_lists = step_ast.as_ref().map(|stms| {
                stms.iter()
                    .map(|s| render_expr(&interpreter::stmt_to_list_expr(s)))
                    .collect::<Vec<_>>()
                    .join(",")
            });
            let body_lists = body_ast.iter()
                .map(|s| render_expr(&interpreter::stmt_to_list_expr(s)))
                .collect::<Vec<_>>()
                .join(",");
            // Compose meta keyed list
            let mut meta_elems: Vec<String> = Vec::new();
            meta_elems.push(format!("persist=({})", persist_lists));
            if let Some(sl) = step_lists {
                meta_elems.push(format!("step=({})", sl));
            }
            if let Some(n) = &name_opt {
                meta_elems.push(format!("name=\"{}\"", n));
            }
            out.push_str("run (#\"block\",#\"loop\",(");
            let meta_str = meta_elems.join(",");
            out.push_str(&meta_str);
            if !meta_str.is_empty() {
                out.push(',');
            }
            out.push_str("),(");
            out.push_str(&body_lists);
            if !body_lists.is_empty() {
                out.push(',');
            }
            out.push_str("))\n");
            i = cursor + after_body;
        } else {
            out.push(bytes[i] as char);
            i += 1;
        }
    }
    if !out.ends_with('\n') {
        out.push('\n');
    }
    // println!("TRANSFORMED:\n{}", out);
    Ok(out)
}

fn extract_brace_block(s: &str) -> Result<(String, usize), ScriptError> {
    let mut depth = 1usize;
    let mut out = String::new();
    let mut i = 0usize;
    let b = s.as_bytes();
    if i >= b.len() || b[i] != b'{' {
        return Err(ScriptError::ParseError("expected `{`".to_string()));
    }
    i += 1;
    while i < b.len() && depth > 0 {
        let c = b[i] as char;
        if c == '{' {
            depth += 1;
            out.push(c);
        } else if c == '}' {
            depth -= 1;
            if depth > 0 { out.push(c); }
        } else {
            out.push(c);
        }
        i += 1;
    }
    if depth != 0 {
        return Err(ScriptError::ParseError("unbalanced `{}` in loop syntax".to_string()));
    }
    Ok((out, i))
}

fn render_expr(e: &ast::Expr) -> String {
    match e {
        ast::Expr::Int(i) => i.to_string(),
        ast::Expr::Str(s) => {
            let mut t = String::new();
            t.push('"');
            t.push_str(s);
            t.push('"');
            t
        }
        ast::Expr::Var(s) => s.clone(),
        ast::Expr::Sym(s) => {
            let mut t = String::new();
            t.push_str("#\"");
            t.push_str(s);
            t.push('"');
            t
        }
        ast::Expr::List(items) => {
            let inner = items.iter().map(|li| {
                if let Some(k) = &li.key {
                    format!("{}={}", k, render_expr(&li.value))
                } else {
                    render_expr(&li.value)
                }
            }).collect::<Vec<_>>().join(",");
            let mut t = String::new();
            t.push('(');
            t.push_str(&inner);
            if items.len() == 1 {
                t.push(',');
            }
            t.push(')');
            t
        }
        ast::Expr::Block(stmts) => {
            // Render block as { <stmts as list exprs> }
            let inner = stmts.iter().map(|s| render_expr(&interpreter::stmt_to_list_expr(s))).collect::<Vec<_>>().join(",");
            let mut t = String::new();
            t.push('{');
            t.push_str(&inner);
            t.push('}');
            t
        }
        ast::Expr::SList(items) => {
            let inner = items.iter().map(|x| render_expr(x)).collect::<Vec<_>>().join(",");
            format!("({})", inner)
        }
        ast::Expr::Call(name, args) => {
            let inner = args.iter().map(|x| render_expr(x)).collect::<Vec<_>>().join(",");
            format!("{}({})", name, inner)
        }
        ast::Expr::Add(a,b) => format!("({}+{})", render_expr(a), render_expr(b)),
        ast::Expr::Sub(a,b) => format!("({}-{})", render_expr(a), render_expr(b)),
        ast::Expr::Mul(a,b) => format!("({}*{})", render_expr(a), render_expr(b)),
        ast::Expr::Div(a,b) => format!("({}/{})", render_expr(a), render_expr(b)),
        ast::Expr::Mod(a,b) => format!("({}%{})", render_expr(a), render_expr(b)),
        ast::Expr::Pow(a,b) => format!("({}**{})", render_expr(a), render_expr(b)),
        ast::Expr::Gt(a,b) => format!("({}>{})", render_expr(a), render_expr(b)),
        ast::Expr::Lt(a,b) => format!("({}<{})", render_expr(a), render_expr(b)),
        ast::Expr::Custom(a, op, b) => format!("({} <{}> {})", render_expr(a), op, render_expr(b)),
        ast::Expr::Map(list_expr, func_name) => format!("({})|{}", render_expr(list_expr), func_name),
        ast::Expr::Group(g) => format!("({})", render_expr(g)),
        ast::Expr::Index(lst, idx) => format!("{}[{}]", render_expr(lst), render_expr(idx)),
        ast::Expr::If(c, t, e) => {
            let mut s = format!("if {} {}", render_expr(c), render_expr(t));
            if let Some(else_e) = e {
                s.push_str(" else ");
                s.push_str(&render_expr(else_e));
            }
            s
        }
    }
}
pub fn shell_transform_line(line: &str) -> String {
    let line = line.trim();
    if line.is_empty() {
        return "\n".to_string();
    }
    if line == ":quit" || line == ":exit" {
        return "\n".to_string();
    }
    if line == ":help" {
        return "print \"commands: :help, :quit, :types, :type NAME\" \n".to_string();
    }
    if line == ":types" {
        return "list types\n".to_string();
    }
    if let Some(rest) = line.strip_prefix(":type ") {
        let mut s = String::from("list type ");
        s.push_str(rest.trim());
        s.push('\n');
        return s;
    }
    let starts_with_keyword = ["let", "print", "list", "type", "types", "call", "reg", "run"]
        .iter()
        .any(|k| line.starts_with(k));
    if !starts_with_keyword {
        let ident_start = Regex::new(r"^[a-zA-Z_]").unwrap();
        let number_start = Regex::new(r"^-?[0-9]").unwrap();
        let is_expr_start = line.starts_with('(')
            || line.starts_with('"')
            || ident_start.is_match(line)
            || number_start.is_match(line);
        if is_expr_start {
            let mut s = String::from("print ");
            s.push_str(line);
            s.push('\n');
            return s;
        }
    }
    if line.ends_with(';') || line.ends_with('\n') {
        line.to_string()
    } else {
        let mut s = String::from(line);
        s.push('\n');
        s
    }
}

#[cfg(test)]
mod tests {
    use super::{interpret_script, shell_transform_line};

    #[test]
    fn basic_script() {
        let src = r#"
            let a=1
            let b=2
            let c=a+b
            print c
            print "c={}" c
        "#;
        let out = interpret_script(src).unwrap();
        assert_eq!(out, vec!["3", "c=3"]);
    }

    #[test]
    fn list_commands() {
        let src = r#"
            list types
            list type testobj
        "#;
        let out = interpret_script(src).unwrap();
        assert!(out.len() >= 2);
    }

    #[test]
    fn math_ops_and_pow_mod() {
        let src = r#"
            let a=2**3
            let b=7%3
            print a
            print b
        "#;
        let out = interpret_script(src).unwrap();
        assert_eq!(out, vec!["8", "1"]);
    }

    #[test]
    fn function_and_run_list() {
        let src = r#"
            let dd(x,y)=x+y
            let a=3
            let b=4
            run (#"dd",a,b)
        "#;
        let out = interpret_script(src).unwrap();
        assert_eq!(out, vec!["7"]);
    }

    #[test]
    fn custom_operator_registration_and_use() {
        let src = r#"
            let add2(x,y)=x+y
            reg operator <plus> add2
            let r=1 <plus> 2
            print r
        "#;
        let out = interpret_script(src).unwrap();
        assert_eq!(out, vec!["3"]);
    }

    #[test]
    fn pow_right_associative() {
        let src = r#"
            let a=2**3**2
            print a
        "#;
        let out = interpret_script(src).unwrap();
        assert_eq!(out, vec!["512"]);
    }

    #[test]
    fn custom_operator_precedence_with_mul() {
        let src = r#"
            let add2(x,y)=x+y
            reg operator <plus> add2
            let r=1 <plus> 2*3
            print r
        "#;
        let out = interpret_script(src).unwrap();
        assert_eq!(out, vec!["7"]);
    }

    #[test]
    fn print_template_no_arg() {
        let src = r#"
            print "hello"
        "#;
        let out = interpret_script(src).unwrap();
        assert_eq!(out, vec!["hello"]);
    }

    #[test]
    fn negative_exponent_error() {
        let src = r#"
            let a=2**-1
            print a
        "#;
        let err = interpret_script(src).unwrap_err();
        match err {
            super::ScriptError::RuntimeError(msg) => assert!(msg.contains("negative exponent")),
            _ => panic!("expected runtime error"),
        }
    }

    #[test]
    fn shell_transform_ident_to_print() {
        assert_eq!(shell_transform_line("abc"), "print abc\n");
        assert_eq!(shell_transform_line("  data_1  "), "print data_1\n");
        assert_eq!(shell_transform_line(":types"), "list types\n");
        assert_eq!(shell_transform_line(":type testobj"), "list type testobj\n");
    }

    #[test]
    fn shell_transform_expression_to_print() {
        assert_eq!(shell_transform_line("a+b"), "print a+b\n");
        assert_eq!(shell_transform_line("2**3"), "print 2**3\n");
        assert_eq!(shell_transform_line("(1 + 2) * 3"), "print (1 + 2) * 3\n");
    }

    #[test]
    fn sym_and_str_conversions() {
        let src = r#"
            print #"hello"
            print 'dd
        "#;
        let out = interpret_script(src).unwrap();
        assert_eq!(out, vec!["hello", "dd"]);
    }

    #[test]
    fn list_map_pipeline() {
        let src = r#"
            let id(x)=x
            print ((#"aa",#"bb",#"cc") |id)
        "#;
        let out = interpret_script(src).unwrap();
        assert_eq!(out, vec!["(aa bb cc)"]);
    }

    #[test]
    fn keyed_list_indexing_and_get() {
        let src = r#"
            let lst=(a=1,2,4)
            print lst["a"]
            print lst[0]
            print lst[1]
            get lst a
            get lst 'a
        "#;
        let out = interpret_script(src).unwrap();
        assert_eq!(out, vec!["1", "1", "2", "1", "1"]);
    }
    #[test]
    fn func_call_syntax_equivalent_to_run() {
        let src = r#"
            let add(x,y)=x+y
            print add(1,2)
            run (#"add",1,2)
        "#;
        let out = interpret_script(src).unwrap();
        assert_eq!(out, vec!["3", "3"]);
    }
    #[test]
    fn square_list_literal_values() {}
    #[test]
    fn shell_auto_print_executes_expression() {
        let src = {
            let mut s = String::new();
            s.push_str("let a=1\n");
            s.push_str("let b=2\n");
            s.push_str(&shell_transform_line("a+b"));
            s
        };
        let out = interpret_script(&src).unwrap();
        assert_eq!(out, vec!["3"]);
    }

    #[test]
    fn run_list_equivalence_for_let_and_print() {
        let src = r#"
            let a=1
            let b=2
            run (#"let","c",a+b)
            run (#"print",c)
            run (#"print_template","c={}",c)
        "#;
        let out = interpret_script(src).unwrap();
        assert_eq!(out, vec!["3", "c=3"]);
    }

    #[test]
    fn run_list_block_notest() {
        let src = r#"
            run (#"block",#"notest",(), ((#"print","hi"),(#"let","x",1)))
        "#;
        let out = interpret_script(src).unwrap();
        assert_eq!(out, vec!["hi"]);
    }

    #[test]
    fn run_let_ident_equals_sym() {
        let src = r#"
            run (let, a, 1)
            print a
            let a=0
            run (#"let", a, 1)
            print a
        "#;
        let out = interpret_script(src).unwrap();
        assert_eq!(out, vec!["1", "1"]);
    }

    #[test]
    fn value_list_vs_sym_table() {
        let src = r#"
            let a=1
            let b=2
            let c=3
            print (a,b,c)
            print [a,b,c]
            print value_of((a,b,c))
        "#;
        let out = interpret_script(src).unwrap();
        assert_eq!(out, vec!["(a b c)", "(1 2 3)", "(1 2 3)"]);
    }

    #[test]
    fn value_of_single_sym() {
        let src = r#"
            let a=7
            print value_of(#"a")
            print value_of('a)
        "#;
        let out = interpret_script(src).unwrap();
        assert_eq!(out, vec!["7","7"]);
    }

    #[test]
    fn paren_group_vs_sym_list() {
        let src = r#"
            let a=1
            print (a)
            print (a,)
            print (a,b)
            print (a,b,)
            print [a]
            print [a,]
        "#;
        let out = interpret_script(src).unwrap();
        assert_eq!(out, vec!["1","(a)","(a b)","(a b)","(1)","(1)"]);
    }

    #[test]
    fn index_on_grouped_square_list() {
        let src = r#"
            let a=42
            print ([a])[0]
        "#;
        let out = interpret_script(src).unwrap();
        assert_eq!(out, vec!["42"]);
    }

    #[test]
    fn square_list_index_without_group_should_fail() {
        let src = r#"
            let a=1
            print [a][0]
        "#;
        let err = interpret_script(src).unwrap_err();
        match err {
            super::ScriptError::ParseError(_) => {},
            _ => panic!("expected parse error for [a][0]"),
        }
    }

    #[test]
    fn run_more_tbs_loop_demo() {
        let src = std::fs::read_to_string("src/more.tbs").unwrap();
        let out = interpret_script(&src).unwrap();
        // In test mode the shell sets test_mode=true; here we run normal mode (2 iterations if test_mode, 3 otherwise),
        // Our interpreter runs 3 iterations in normal mode: sums 5,7,9
        // The second loop prints "outer start" and then breaks to label "aaa", so "outer end" is skipped and loop terminates.
        assert_eq!(out, vec!["5","7","9","outer start"]);
    }

}
