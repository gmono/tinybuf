mod ast;
mod interpreter;
lalrpop_util::lalrpop_mod!(grammar); // generated by build.rs from grammar.lalrpop
pub use interpreter::Interpreter;
pub use ast::Stmt;

use thiserror::Error;

#[derive(Error, Debug)]
pub enum ScriptError {
    #[error("lex error at byte {0}")]
    LexError(usize),
    #[error("parse error: {0}")]
    ParseError(String),
    #[error("runtime error: {0}")]
    RuntimeError(String),
}

pub fn parse_program(input: &str) -> Result<Vec<Stmt>, ScriptError> {
    grammar::ProgramParser::new()
        .parse(input)
        .map_err(|e| ScriptError::ParseError(format!("{e}")))
}

pub fn interpret_script(input: &str) -> Result<Vec<String>, ScriptError> {
    let ast = grammar::ProgramParser::new()
        .parse(input)
        .map_err(|e| ScriptError::ParseError(format!("{e}")))?;
    let outputs = interpreter::run(&ast).map_err(|e| ScriptError::RuntimeError(e))?;
    Ok(outputs)
}

#[cfg(test)]
mod tests {
    use super::interpret_script;

    #[test]
    fn basic_script() {
        let src = r#"
            let a=1
            let b=2
            let c=a+b
            print c
            print "c={}" c
        "#;
        let out = interpret_script(src).unwrap();
        assert_eq!(out, vec!["3", "c=3"]);
    }

    #[test]
    fn list_commands() {
        let src = r#"
            list types
            list type testobj
        "#;
        let out = interpret_script(src).unwrap();
        assert!(out.len() >= 2);
    }

    #[test]
    fn math_ops_and_pow_mod() {
        let src = r#"
            let a=2**3
            let b=7%3
            print a
            print b
        "#;
        let out = interpret_script(src).unwrap();
        assert_eq!(out, vec!["8", "1"]);
    }

    #[test]
    fn function_and_run_list() {
        let src = r#"
            let dd(x,y)=x+y
            let a=3
            let b=4
            run (dd a b)
        "#;
        let out = interpret_script(src).unwrap();
        assert_eq!(out, vec!["7"]);
    }

    #[test]
    fn custom_operator_registration_and_use() {
        let src = r#"
            let add2(x,y)=x+y
            reg operator <plus> add2
            let r=1 <plus> 2
            print r
        "#;
        let out = interpret_script(src).unwrap();
        assert_eq!(out, vec!["3"]);
    }
}
