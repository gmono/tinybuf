use crate::ast::*;
grammar;

match {
    "let",
    "print",
    "return",
    "get",
    "list",
    "types",
    "type",
    "call",
    "reg",
    "operator",
    "run",
    "=",
    "+", "-", "**", "*", "/",
    "%",
    "(", ")", "{", "}", ".", ",", "#", "'", "|", "[", "]",
    ";",
    r#""([^"\\]|\\.)*""#,
    r"[a-zA-Z_][a-zA-Z0-9_]*",
    r"-?[0-9]+",
    r"[ \t\r\f]+" => { },
    r"//[^\n]*" => { },
    "\n",
    r"<[a-zA-Z0-9_]+>",
}

pub Program: Vec<Stmt> = Stmt*;

Stmt: Stmt = {
    Sep* "let" <ls:LetStmt> Sep => ls,
    Sep* "print" <e:Expr> Sep => Stmt::PrintExpr(e),
    Sep* "print" <s:StringLit> Sep => Stmt::PrintTemplate(s, None),
    Sep* "print" <s:StringLit> <e:Expr> Sep => Stmt::PrintTemplate(s, Some(e)),
    Sep* "return" <e:Expr> Sep => Stmt::Return(e),
    Sep* "list" "types" Sep => Stmt::ListTypes,
    Sep* "list" "type" <name:Ident> Sep => Stmt::ListType(name),
    Sep* "call" <t:Ident> "." <op:Ident> "(" ")" Sep => Stmt::Call(t, op, vec![]),
    Sep* "call" <t:Ident> "." <op:Ident> "(" <args:ArgNonEmpty> ")" Sep => Stmt::Call(t, op, args),
    Sep* "reg" "operator" <op:CustomOp> <fname:Ident> Sep => Stmt::RegOp(op, fname),
    Sep* "run" "(" ")" Sep => Stmt::RunList(vec![]),
    Sep* "run" "(" <items:LispArgs> ")" Sep => Stmt::RunList(items),
    Sep* "get" <lst:Expr> <k:Ident> Sep => Stmt::PrintExpr(Expr::Index(Box::new(lst), Box::new(Expr::Str(k)))),
    Sep* "get" <lst:Expr> <k:StringLit> Sep => Stmt::PrintExpr(Expr::Index(Box::new(lst), Box::new(Expr::Str(k)))),
    Sep* "get" <lst:Expr> "'" <k:Ident> Sep => Stmt::PrintExpr(Expr::Index(Box::new(lst), Box::new(Expr::Str(k)))),
    Sep* "get" <lst:Expr> <i:Number> Sep => Stmt::PrintExpr(Expr::Index(Box::new(lst), Box::new(Expr::Int(i)))),
    Sep* <e:Expr> Sep => Stmt::ExprStmt(e),
};

LetStmt: Stmt = {
    <name:Ident> "(" ")" "=" <body:Expr> => Stmt::LetFunc(name, vec![], body),
    <name:Ident> "(" <ps:ParamNonEmpty> ")" "=" <body:Expr> => Stmt::LetFunc(name, ps, body),
    <name:Ident> "(" ")" "=" "{" <b:Stmt*> "}" => Stmt::LetFuncBlock(name, vec![], b),
    <name:Ident> "(" <ps:ParamNonEmpty> ")" "=" "{" <b:Stmt*> "}" => Stmt::LetFuncBlock(name, ps, b),
    <name:Ident> "=" <e:Expr> => Stmt::Let(name, e),
};

ArgNonEmpty: Vec<Expr> = {
    <e:Expr> => vec![e],
    <l:ArgNonEmpty> "," <e:Expr> => { l.into_iter().chain(std::iter::once(e)).collect() },
};

Param: (Option<String>, String) = {
    <n:Ident> => (None, n),
    <t:Ident> <n:Ident> => (Some(t), n),
};

ParamNonEmpty: Vec<(Option<String>, String)> = {
    <p:Param> => vec![p],
    <l:ParamNonEmpty> "," <p:Param> => l.into_iter().chain(std::iter::once(p)).collect(),
};

CustomOp: String = r"<[a-zA-Z0-9_]+>" => {
    let s = <>;
    s[1..s.len()-1].to_string()
};

Sep: () = { ";" => (), "\n" => () };

Expr: Expr = AddSub;

AddSub: Expr = {
    <l:AddSub> "+" <r:Term> => Expr::Add(Box::new(l), Box::new(r)),
    <l:AddSub> "-" <r:Term> => Expr::Sub(Box::new(l), Box::new(r)),
    <l:AddSub> <op:CustomOp> <r:Term> => Expr::Custom(Box::new(l), op, Box::new(r)),
    <l:AddSub> "|" <f:Ident> => Expr::Map(Box::new(l), f),
    Term,
};

Term: Expr = {
    <l:Term> "*" <r:Power> => Expr::Mul(Box::new(l), Box::new(r)),
    <l:Term> "/" <r:Power> => Expr::Div(Box::new(l), Box::new(r)),
    <l:Term> "%" <r:Power> => Expr::Mod(Box::new(l), Box::new(r)),
    Power,
};

Power: Expr = {
    <l:Unary> "**" <r:Power> => Expr::Pow(Box::new(l), Box::new(r)),
    Unary,
};

Unary: Expr = {
    "#" <u:Unary> => Expr::SymToStr(Box::new(u)),
    Postfix,
};

Postfix: Expr = {
    <p:Postfix> "[" <i:Expr> "]" => Expr::Index(Box::new(p), Box::new(i)),
    <p:Postfix> "[" <s:StringLit> "]" => Expr::Index(Box::new(p), Box::new(Expr::Str(s))),
    <p:Postfix> "." <m:Ident> "(" ")" => Expr::MethodCall(Box::new(p), m, vec![]),
    <p:Postfix> "." <m:Ident> "(" <args:ArgNonEmpty> ")" => Expr::MethodCall(Box::new(p), m, args),
    <p:Postfix> "(" ")" => Expr::Call(Box::new(p), vec![]),
    <p:Postfix> "(" <args:ArgNonEmpty> ")" => Expr::Call(Box::new(p), args),
    Factor,
};

CommaList: Vec<ListItem> = {
    <e:ListItem> => vec![e],
    <l:CommaList> "," <e:ListItem> => l.into_iter().chain(std::iter::once(e)).collect(),
};

ListItem: ListItem = {
    <k:Ident> "=" <v:Expr> => ListItem{ key: Some(k), value: v },
    <k:StringLit> "=" <v:Expr> => ListItem{ key: Some(k), value: v },
    <v:Expr> => ListItem{ key: None, value: v },
};

KeyValItem: ListItem = {
    <k:Ident> "=" <v:Expr> => ListItem{ key: Some(k), value: v },
    <k:StringLit> "=" <v:Expr> => ListItem{ key: Some(k), value: v },
};

LispKeyword: String = {
    "let" => "let".to_string(),
    "print" => "print".to_string(),
    "return" => "return".to_string(),
    "get" => "get".to_string(),
    "list" => "list".to_string(),
    "types" => "types".to_string(),
    "type" => "type".to_string(),
    "call" => "call".to_string(),
    "reg" => "reg".to_string(),
    "operator" => "operator".to_string(),
    "run" => "run".to_string(),
    "+" => "+".to_string(),
    "-" => "-".to_string(),
    "**" => "**".to_string(),
    "*" => "*".to_string(),
    "/" => "/".to_string(),
    "%" => "%".to_string(),
};

LispAtom: ListItem = {
    <kv:KeyValItem> => kv,
    <v:Unary> => ListItem{ key: None, value: v },
    <k:LispKeyword> => ListItem{ key: None, value: Expr::Var(k) },
};

LispArgs: Vec<ListItem> = {
    <e:LispAtom> => vec![e],
    <l:LispArgs> ","? <e:LispAtom> => l.into_iter().chain(std::iter::once(e)).collect(),
};

OneLispArg: ListItem = {
    ","? <e:LispAtom> => e,
};

LispArgsRest: Vec<ListItem> = {
    <e:OneLispArg> => vec![e],
    <l:LispArgsRest> <e:OneLispArg> => l.into_iter().chain(std::iter::once(e)).collect(),
};

Factor: Expr = {
    <n:Number> => Expr::Int(n),
    <v:Ident> => Expr::Var(v),
    "'" <v:Ident> => Expr::Sym(v),
    <s:StringLit> => Expr::Str(s),
    "(" ")" => Expr::List(vec![]),
    "(" <items:LispArgs> ")" => crate::ast::parse_lisp_group(items),
};

Ident: String = r"[a-zA-Z_][a-zA-Z0-9_]*" => <>.to_string();
Number: i64 = r"-?[0-9]+" => <>.parse().unwrap();
StringLit: String = r#""([^"\\]|\\.)*""# => {
    let s = <>;
    s[1..s.len()-1].to_string()
};
