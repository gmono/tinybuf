mod ast;
mod interpreter;
mod grammar; // generated by build.rs from grammar.lalrpop

use thiserror::Error;

#[derive(Error, Debug)]
pub enum ScriptError {
    #[error("lex error at byte {0}")]
    LexError(usize),
    #[error("parse error: {0}")]
    ParseError(String),
    #[error("runtime error: {0}")]
    RuntimeError(String),
}

pub fn interpret_script(input: &str) -> Result<Vec<String>, ScriptError> {
    let ast = grammar::ProgramParser::new()
        .parse(input)
        .map_err(|e| ScriptError::ParseError(format!("{e}")))?;
    let outputs = interpreter::run(&ast).map_err(|e| ScriptError::RuntimeError(e))?;
    Ok(outputs)
}

#[cfg(test)]
mod tests {
    use super::interpret_script;

    #[test]
    fn basic_script() {
        let src = r#"
            let a=1
            let b=2
            let c=a+b
            print c
            print "c={}" c
        "#;
        let out = interpret_script(src).unwrap();
        assert_eq!(out, vec!["3", "c=3"]);
    }

    #[test]
    fn list_commands() {
        let src = r#"
            list types
            list type testobj
        "#;
        let out = interpret_script(src).unwrap();
        assert!(out.len() >= 2);
    }
}
