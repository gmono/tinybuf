# TinyBuf 架构与集成分析（typecore / dynsys / dyn integration / plugin / 序列化）

## 概览
- 目标：将独立的 OOP 运行时与序列化系统彻底解耦，保留一个干净的核心库，同时通过“中间层”将序列化与插件能力对接。
- 现状：
  - `typecore`为纯类型与对象的基础模型，独立无序列化依赖。
  - `dynsys`为独立的 OOP 运行时（注册类型/操作、签名校验、调用），只依赖`typecore`。
  - `dyn integration`是针对`tinybuf_value`的适配层，承载序列化器挂载、trait、以及以`tinybuf_value`为参数的操作分发。
  - 插件系统（可选）提供运行时扩展、DLL加载、以GUID/tag标识的读写与值操作；序列化在写入时可产生“带插件ID”的自描述盒子。

## 核心组件与关系

### typecore
- 职责：提供类型定义、方法签名与运行时对象`typed_obj`的抽象，完全与序列化系统无关。
- 关键结构：
  - 类型与方法元数据：`f:\tinybuf\src\dyn_sys\type_core.h:33–64`
  - 运行时对象：`f:\tinybuf\src\dyn_sys\type_core.h:66–70`
  - 基础操作：初始化/分配/拷贝/移动/析构等：`f:\tinybuf\src\dyn_sys\type_core.h:72–86`

### dynsys（独立库）
- 职责：围绕`typed_obj`实现 OOP 运行时，管理“类型-操作-签名”，支持类型化调用。
- 特点：不包含任何`tinybuf_*`依赖，仅与`typecore`协作。
- 关键能力与位置：
  - 类型注册/查询：`f:\tinybuf\src\dyn_sys\dyn_sys.c:118–152`
  - 操作注册（类型化签名）：`f:\tinybuf\src\dyn_sys\dyn_sys.c:182–222`
  - 操作元信息查询：`f:\tinybuf\src\dyn_sys\dyn_sys.c:167–181`、`f:\tinybuf\src\dyn_sys\dyn_sys.c:153–166`
  - 调用执行（typed_obj）：`f:\tinybuf\src\dyn_sys\dyn_sys.c:234–253`

### dyn integration（中间层）
- 职责：将`tinybuf_value`与 OOP 体系对接：
  - 以`tinybuf_value`为自/参对象进行操作分发与签名校验。
  - 维护每种类型的自定义序列化器（read/write/dump）与“可序列化”开关。
  - 提供 trait，将多个类型的同名操作聚合并统一分发。
- 关键能力与位置：
  - 类型与操作注册（`tinybuf_value`形态）：`f:\tinybuf\src\dyn_sys\dyn_integration.c:126–193`
  - 类型化操作注册与签名存储（`tinybuf_plugin_value_op_fn`）：`f:\tinybuf\src\dyn_sys\dyn_integration.c:303–343`
  - 操作执行（参数类型校验与分发）：`f:\tinybuf\src\dyn_sys\dyn_integration.c:283–302`
  - 序列化器挂载/开关/查询：`f:\tinybuf\src\dyn_sys\dyn_integration.c:355–370`、`f:\tinybuf\src\dyn_sys\dyn_integration.c:371–393`
  - trait 数据结构与注册：`f:\tinybuf\src\dyn_sys\dyn_integration.c:398–414`及后续 API

## 分离背景与修复
- 历史问题：序列化系统相关头文件（如`tinybuf_buffer.h`、`tinybuf_memory.h`）出现在`dyn_sys.c`中，导致核心库被污染。
- 修复策略：彻底“物理分离”——`dyn_sys.c`保留纯`typed_obj`运行时；所有与`tinybuf_value`、序列化器、trait相关的实现挪至`dyn_integration.c`。
- 现状确认：
  - `dyn_sys.c`仅包含标准库与自身头（`f:\tinybuf\src\dyn_sys\dyn_sys.c:1–5`），不再引用序列化相关头。
  - `dyn_integration.c`包含序列化系统的头并维护中间层状态（`f:\tinybuf\src\dyn_sys\dyn_integration.c:1–8`）。

## 序列化系统如何协作
- 普通盒子序列化：`tinybuf_value_serialize`根据`_type`生成标准盒子（`f:\tinybuf\src\source\tinybuf_serialize.c:69–154`等）。
- 插件自定义盒子：若`value->_custom_box_tag >= 0`，序列化先查插件GUID并委托插件写入“带插件ID”的自描述盒子：
  - 检测与委托：`f:\tinybuf\src\source\tinybuf_serialize.c:74–86`
  - 实际写入（包含字符串池与payload）：`f:\tinybuf\src\source\tinybuf_write.c:673–746`
- 中间层类型向`custom`桥接：遍历中间层已注册类型，凡标记为“可序列化”且挂载了读函数的，自动注册为序列化系统自定义类型（`f:\tinybuf\src\source\tinybuf_plugin.c:689–709`）。这使无插件场景下也能以名称驱动读写。

## 插件系统（可选模块）
### 能力与接口
- 运行时扩展：支持DLL加载、目录扫描，注册插件描述器与其操作列表（`f:\tinybuf\src\source\tinybuf_plugin.c:339–463`、`f:\tinybuf\src\source\tinybuf_plugin.c:680–761`）。
- 读/写/dump/show：按tag或GUID定位并调用插件的读写/展示/转储函数（`f:\tinybuf\src\source\tinybuf_plugin.c:122–190`、`f:\tinybuf\src\include\tinybuf_plugin.h:36–52`）。
- 值操作：针对`tinybuf_value`暴露操作方法，支持按运行时索引或tag调用（`f:\tinybuf\src\source\tinybuf_plugin.c:280–338`）。
- 运行时索引与映射：通过GUID/tag建立`runtime_index`，用于快速分发（`f:\tinybuf\src\source\tinybuf_plugin.c:239–257`）。

### 与中间层、custom 的关系
- 中间层负责把“类型是否可序列化与其读写dump函数”进行登记；`tinybuf_oop_register_types_to_custom`将其批量注册到`custom`体系（`f:\tinybuf\src\source\tinybuf_plugin.c:689–709`）。
- 插件负责按GUID/tag提供专属读写与值操作；序列化在有`_custom_box_tag`时优先委托插件写入“带插件ID”的盒子（`f:\tinybuf\src\source\tinybuf_serialize.c:74–86`）。

### 测试与使用场景
- 基本插件写入/读取：`f:\tinybuf\benchmark.cpp:1315–1358`。
- DLL插件加载与值操作：`f:\tinybuf\benchmark.cpp:1522–1558`（如大小写转换）。
- 插件自定义盒子读写与内容校验：`f:\tinybuf\benchmark.cpp:1583–1617`。
- 单元测试示例（系统扩展）：`f:\tinybuf\tests\unit\system_extend_plugin_tests.cpp:16–52`、`f:\tinybuf\tests\unit\system_extend_plugin_tests.cpp:91–122`。
- 中间层 trait 示例（跨类型操作）：`f:\tinybuf\tests\unit\basic_custom_tests.cpp:152–200`。

## 插件系统的必要性与裁剪建议
### 何时必要
- 需要运行时扩展（DLL加载、目录扫描）、按GUID/tag动态分发读写与值操作。
- 需要写入“带插件ID”的自描述盒子，以实现跨系统互通与扩展协议。

### 何时可裁剪
- 仅需要内部类型的自定义盒子读写，不需要运行时扩展或GUID标识。
- 值操作可直接通过中间层的`tinybuf_oop_*`体系实现，无需插件挂载操作列表。

### 裁剪策略（建议）
- 编译期开关：
  - 禁用`_custom_box_tag`分支与对`tinybuf_try_write_plugin_id_box`的调用（改写`f:\tinybuf\src\source\tinybuf_serialize.c:74–86`与`f:\tinybuf\src\source\tinybuf_write.c:673–746`逻辑路径），统一走标准盒子写入。
- 测试分级：将插件相关测试与benchmark拆分到可选目标或通过宏屏蔽。
- 保留中间层与`custom`体系：继续使用`tinybuf_oop_attach_serializers`与`tinybuf_oop_register_types_to_custom`，维持名称驱动的自定义读写能力。

## 关键代码位置索引
- typecore
  - 类型与方法元数据：`f:\tinybuf\src\dyn_sys\type_core.h:33–64`
  - 运行时对象：`f:\tinybuf\src\dyn_sys\type_core.h:66–70`
  - 基础操作：`f:\tinybuf\src\dyn_sys\type_core.h:72–86`
- dynsys（独立库）
  - 类型注册：`f:\tinybuf\src\dyn_sys\dyn_sys.c:118–145`
  - 类型查询：`f:\tinybuf\src\dyn_sys\dyn_sys.c:146–152`
  - 操作元信息与计数：`f:\tinybuf\src\dyn_sys\dyn_sys.c:153–181`
  - 类型化操作注册：`f:\tinybuf\src\dyn_sys\dyn_sys.c:182–222`
  - 操作调用执行：`f:\tinybuf\src\dyn_sys\dyn_sys.c:234–253`
- dyn integration（中间层）
  - 头文件与依赖：`f:\tinybuf\src\dyn_sys\dyn_integration.c:1–8`
  - 类型与操作注册：`f:\tinybuf\src\dyn_sys\dyn_integration.c:126–193`
  - 类型化操作注册：`f:\tinybuf\src\dyn_sys\dyn_integration.c:303–343`
  - 操作执行：`f:\tinybuf\src\dyn_sys\dyn_integration.c:283–302`
  - 序列化器挂载/开关/查询：`f:\tinybuf\src\dyn_sys\dyn_integration.c:355–393`
  - trait 数据结构：`f:\tinybuf\src\dyn_sys\dyn_integration.c:398–414`
- 序列化与插件
  - `tinybuf_value_serialize`与插件分支：`f:\tinybuf\src\source\tinybuf_serialize.c:69–86`
  - 写入“带插件ID盒子”：`f:\tinybuf\src\source\tinybuf_write.c:673–746`
  - 插件读写/展示/转储：`f:\tinybuf\src\source\tinybuf_plugin.c:122–190`
  - 插件值操作：`f:\tinybuf\src\source\tinybuf_plugin.c:280–338`
  - 运行时索引映射：`f:\tinybuf\src\source\tinybuf_plugin.c:239–257`
  - 中间层类型注册到`custom`：`f:\tinybuf\src\source\tinybuf_plugin.c:689–709`

## 结论与建议
- 已实现“独立核心库 + 中间集成层”的物理分离：核心`dynsys`不再污染序列化依赖，中间层承载所有`tinybuf_value`与序列化/trait相关逻辑。
- 序列化系统通过中间层的“序列化器挂载”与`custom`桥接实现无插件场景；在需要动态扩展时，插件系统提供DLL加载、GUID/tag分发与“带插件ID盒子”的写入能力。
- 是否保留插件取决于业务需求：
  - 若仅内部使用且不需运行时扩展，建议以编译期开关裁剪插件路径，保留中间层与`custom`能力即可。
  - 若需要第三方扩展或跨系统互通，建议保留插件系统，并将其作为可选模块纳入构建与测试策略。 

