use crate::ast::*;
use crate::interpreter::stmt_to_list_expr;
grammar;

match {
    "let",
    "print",
    "reg",
    "operator",
    "return",
    "if",
    "else",
    "break",
    "next",
    "to",
    "list",
    "types",
    "type",
    "call",
    "get",
    "run",
    "with",
    "=",
    ":",
    "+", "-", "**", "*", "/", ">", "<",
    "%",
    "(", ")", "{", "}", ".", ",", "#", "'", "|", "[", "]",
    ";",
    r#""([^"\\]|\\.)*""#,
    r"[a-zA-Z_][a-zA-Z0-9_]*",
    r"-?[0-9]+",
    r"[ \t\r\f]+" => { },
    r"//[^\n]*" => { },
    "\n",
    r"<[a-zA-Z0-9_]+>",
}

StmtList: Vec<Stmt> = {
    => vec![],
    <first:Stmt> <rest:(Sep+ <Stmt>)*> => {
        let mut v = vec![first];
        for st in rest { v.push(st); }
        v
    },
};

pub Program: Vec<Stmt> = {
    Sep* <list:StmtList> => list,
};

Stmt: Stmt = {
    MatchedStmt,
    UnmatchedStmt,
};

SimpleStmt: Stmt = {
    "let" <ls:LetStmt> => ls,
    "print" <s:StringLit> <e:Expr> => Stmt::PrintTemplate(s, Some(e)),
    "print" <e:Expr> => Stmt::PrintExpr(e),
    "return" <e:Expr?> => Stmt::Return(e),
    "break" "to" <lbl:Ident> => Stmt::Break(Some(lbl)),
    "break" => Stmt::Break(None),
    "next" => Stmt::Next,
    "list" "types" => Stmt::ListTypes,
    "list" "type" <name:Ident> => Stmt::ListType(name),
    "call" <t:Ident> "." <op:Ident> "(" <args:ArgNonEmpty> ")" => Stmt::Call(t, op, args),
    "call" <t:Ident> "." <op:Ident> "(" ")" => Stmt::Call(t, op, vec![]),
    "reg" "operator" <op:CustomOp> <fname:Ident> => Stmt::RegOp(op, fname),
    "run" "(" <items:ArgNonEmpty> ")" => Stmt::RunList(items),
    "run" "(" ")" => Stmt::RunList(vec![]),
    <name:Ident> "=" <e:Expr> => Stmt::Let(name, e),
    <e:ExprNoIf> => Stmt::ExprStmt(e),
    "get" <lst:Expr> <k:Ident> => Stmt::PrintExpr(Expr::Index(Box::new(lst), Box::new(Expr::Str(k)))),
    "get" <lst:Expr> <k:StringLit> => Stmt::PrintExpr(Expr::Index(Box::new(lst), Box::new(Expr::Str(k)))),
    "get" <lst:Expr> "'" <k:Ident> => Stmt::PrintExpr(Expr::Index(Box::new(lst), Box::new(Expr::Str(k)))),
    "get" <lst:Expr> <i:Number> => Stmt::PrintExpr(Expr::Index(Box::new(lst), Box::new(Expr::Int(i)))),
};

MatchedStmt: Stmt = {
    SimpleStmt,
    "if" <c:Expr> <t:StmtBlock> "else" <e:MatchedStmt> => Stmt::If(c, Box::new(t), Some(Box::new(e))),
};

UnmatchedStmt: Stmt = {
    "if" <c:Expr> <t:StmtBlock> => Stmt::If(c, Box::new(t), None),
};

StmtBlock: Stmt = {
    <b:Block> => Stmt::ExprStmt(Expr::BlockNoValue(b)),
};

/* colon-if lowered in lexer prepass */

LetStmt: Stmt = {
    <name:Ident> "(" ")" "=" <body:Expr> => Stmt::LetFunc(name, vec![], vec![Stmt::Return(Some(body))]),
    <name:Ident> "(" <ps:ParamNonEmpty> ")" "=" <body:Expr> => Stmt::LetFunc(name, ps, vec![Stmt::Return(Some(body))]),
    <name:Ident> "(" ")" "=" <b:Block> => {
          Stmt::LetFunc(name, vec![], b)
     },
     <name:Ident> "(" <ps:ParamNonEmpty> ")" "=" <b:Block> => {
          Stmt::LetFunc(name, ps, b)
     },
    <name:Ident> "=" <e:Expr> => Stmt::Let(name, e),
};

/* dangling-else unsupported in statement form; use if-expr */

ArgNonEmpty: Vec<Expr> = {
    <e:Expr> => vec![e],
    <l:ArgNonEmpty> "," <e:Expr> => { l.into_iter().chain(std::iter::once(e)).collect() },
};

ArgNonEmptyNoIf: Vec<Expr> = {
    <e:ExprNoIf> => vec![e],
    <l:ArgNonEmptyNoIf> "," <e:ExprNoIf> => { l.into_iter().chain(std::iter::once(e)).collect() },
};

Block: Vec<Stmt> = {
    "{" Sep* "}" => vec![],
    "{" Sep* <first:Stmt> <rest:(Sep+ <Stmt>)*> Sep* "}" => {
        let mut v = vec![first];
        for st in rest { v.push(st); }
        v
    },
};

/* colon-if lowered in lexer prepass */

ParamNonEmpty: Vec<String> = {
    <p:Ident> => vec![p],
    <l:ParamNonEmpty> "," <p:Ident> => { l.into_iter().chain(std::iter::once(p)).collect() },
};

CustomOp: String = r"<[a-zA-Z0-9_]+>" => {
    let s = <>;
    s[1..s.len()-1].to_string()
};

Sep: () = { ";" => (), "\n" => () };

Expr: Expr = {
    IfExprWithElse,
    Cmp,
};

ExprNoIf: Expr = {
    Cmp,
};

IfExprWithElse: Expr = {
    "if" <c:Expr> <t:BlockExpr> "else" <e:BlockExpr> => Expr::If(Box::new(c), Box::new(t), Some(Box::new(e))),
};

BlockExpr: Expr = {
    <b:Block> => Expr::Block(b),
};



Cmp: Expr = {
    <l:AddSub> ">" <r:AddSub> => Expr::Gt(Box::new(l), Box::new(r)),
    <l:AddSub> "<" <r:AddSub> => Expr::Lt(Box::new(l), Box::new(r)),
    AddSub,
};

AddSub: Expr = {
    <l:AddSub> "+" <r:Term> => Expr::Add(Box::new(l), Box::new(r)),
    <l:AddSub> "-" <r:Term> => Expr::Sub(Box::new(l), Box::new(r)),
    <l:AddSub> <op:CustomOp> <r:Term> => Expr::Custom(Box::new(l), op, Box::new(r)),
    <l:AddSub> "|" <f:Ident> => Expr::Map(Box::new(l), f),
    Term,
};

Term: Expr = {
    <l:Term> "*" <r:Power> => Expr::Mul(Box::new(l), Box::new(r)),
    <l:Term> "/" <r:Power> => Expr::Div(Box::new(l), Box::new(r)),
    <l:Term> "%" <r:Power> => Expr::Mod(Box::new(l), Box::new(r)),
    Power,
};

Power: Expr = {
    <l:Base> "**" <r:Power> => Expr::Pow(Box::new(l), Box::new(r)),
    Base,
};

Base: Expr = {
    Postfix,
    Atom,
};
PrimaryIndexable: Expr = {
    "(" <e:Expr> ")" => Expr::Group(Box::new(e)),
    <v:Ident> => Expr::Var(v),
};

Postfix: Expr = {
    <p:Postfix> "[" <i:Expr> "]" => Expr::Index(Box::new(p), Box::new(i)),
    <f:Ident> "(" <args:ArgNonEmpty> ")" => Expr::Call(f, args),
    <f:Ident> "(" ")" => Expr::Call(f, vec![]),
    PrimaryIndexable,
};

CallArgs: Vec<Expr> = {
    "(" <args:ArgNonEmpty> ")" => args,
    "(" ")" => vec![],
};

Atom: Expr = {
    <n:Number> => Expr::Int(n),
    <s:StringLit> => Expr::Str(s),
    "let" => Expr::Var("let".to_string()),
    "#" <s:StringLit> => Expr::Sym(s),
    "#" <v:Ident> => Expr::Str(v),
    "'" <v:Ident> => Expr::Str(v),
    "(" <items:ListItemsNonEmpty> ")" => Expr::List(items),
    "(" <items:ListItemsNonEmpty> "," ")" => Expr::List(items),
    "(" ")" => Expr::List(vec![]),
    "[" "]" => Expr::Call("value_of".to_string(), vec![Expr::List(vec![])]),
    "[" <items:ListItemsNonEmpty> "]" => Expr::Call("value_of".to_string(), vec![Expr::List(items)]),
    "[" <items:ListItemsNonEmpty> "," "]" => Expr::Call("value_of".to_string(), vec![Expr::List(items)]),
};

AtomNoGroup: Expr = {
    <n:Number> => Expr::Int(n),
    <s:StringLit> => Expr::Str(s),
    "let" => Expr::Var("let".to_string()),
};

PostfixNoGroup: Expr = {
    <p:PostfixNoGroup> "[" <i:ExprNoGroup> "]" => Expr::Index(Box::new(p), Box::new(i)),
    PrimaryIndexableNoGroup,
};

PrimaryIndexableNoGroup: Expr = {
    <v:Ident> => Expr::Var(v),
};

PowerNoGroup: Expr = {
    <l:BaseNoGroup> "**" <r:PowerNoGroup> => Expr::Pow(Box::new(l), Box::new(r)),
    BaseNoGroup,
};

TermNoGroup: Expr = {
    <l:TermNoGroup> "*" <r:PowerNoGroup> => Expr::Mul(Box::new(l), Box::new(r)),
    <l:TermNoGroup> "/" <r:PowerNoGroup> => Expr::Div(Box::new(l), Box::new(r)),
    <l:TermNoGroup> "%" <r:PowerNoGroup> => Expr::Mod(Box::new(l), Box::new(r)),
    PowerNoGroup,
};

AddSubNoGroup: Expr = {
    TermNoGroup,
};

CmpNoGroup: Expr = {
    <l:AddSubNoGroup> ">" <r:AddSubNoGroup> => Expr::Gt(Box::new(l), Box::new(r)),
    <l:AddSubNoGroup> "<" <r:AddSubNoGroup> => Expr::Lt(Box::new(l), Box::new(r)),
    AddSubNoGroup,
};

BaseNoGroup: Expr = {
    PostfixNoGroup,
    AtomNoGroup,
};


ListItemExpr: ListItem = {
    <e:ExprNoGroup> => ListItem{ key: None, value: e },
    <k:Ident> "=" <v:ExprNoGroup> => ListItem{ key: Some(k), value: v },
};

ListItemsNonEmpty: Vec<ListItem> = {
    <i:ListItemExpr> => vec![i],
    <l:ListItemsNonEmpty> "," <i:ListItemExpr> => {
        let mut v = l;
        v.push(i);
        v
    },
};

/* removed Primary */

/* merged into Base */

Ident: String = r"[a-zA-Z_][a-zA-Z0-9_]*" => <>.to_string();
Number: i64 = r"-?[0-9]+" => <>.parse().unwrap();
StringLit: String = r#""([^"\\]|\\.)*""# => {
    let s = <>;
    s[1..s.len()-1].to_string()
};

ExprNoGroup: Expr = {
    CmpNoGroup,
};
