mod ast;
mod interpreter;
lalrpop_util::lalrpop_mod!(grammar); // generated by build.rs from grammar.lalrpop
pub use interpreter::Interpreter;
pub use interpreter::ensure_oop_demo_registered;
pub use ast::Stmt;

use thiserror::Error;
use regex::Regex;

#[derive(Error, Debug)]
pub enum ScriptError {
    #[error("lex error at byte {0}")]
    LexError(usize),
    #[error("parse error: {0}")]
    ParseError(String),
    #[error("runtime error: {0}")]
    RuntimeError(String),
}

pub fn parse_program(input: &str) -> Result<Vec<Stmt>, ScriptError> {
    grammar::ProgramParser::new()
        .parse(input)
        .map_err(|e| ScriptError::ParseError(format!("{e}")))
}

pub fn interpret_script(input: &str) -> Result<Vec<String>, ScriptError> {
    let ast = grammar::ProgramParser::new()
        .parse(input)
        .map_err(|e| ScriptError::ParseError(format!("{e}")))?;
    let outputs = interpreter::run(&ast).map_err(|e| ScriptError::RuntimeError(e))?;
    Ok(outputs)
}

pub fn shell_transform_line(line: &str) -> String {
    let line = line.trim();
    if line.is_empty() {
        return "\n".to_string();
    }
    if line == ":quit" || line == ":exit" {
        return "\n".to_string();
    }
    if line == ":help" {
        return "print \"commands: :help, :quit, :types, :type NAME\" \n".to_string();
    }
    if line == ":types" {
        return "list types\n".to_string();
    }
    if let Some(rest) = line.strip_prefix(":type ") {
        let mut s = String::from("list type ");
        s.push_str(rest.trim());
        s.push('\n');
        return s;
    }
    let starts_with_keyword = ["let", "print", "list", "type", "types", "call", "reg", "run"]
        .iter()
        .any(|k| line.starts_with(k));
    if !starts_with_keyword {
        let ident_start = Regex::new(r"^[a-zA-Z_]").unwrap();
        let number_start = Regex::new(r"^-?[0-9]").unwrap();
        let is_expr_start = line.starts_with('(')
            || line.starts_with('"')
            || ident_start.is_match(line)
            || number_start.is_match(line);
        if is_expr_start {
            let mut s = String::from("print ");
            s.push_str(line);
            s.push('\n');
            return s;
        }
    }
    if line.ends_with(';') || line.ends_with('\n') {
        line.to_string()
    } else {
        let mut s = String::from(line);
        s.push('\n');
        s
    }
}

#[cfg(test)]
mod tests {
    use super::{interpret_script, shell_transform_line};

    #[test]
    fn basic_script() {
        let src = r#"
            let a=1
            let b=2
            let c=a+b
            print c
            print "c={}" c
        "#;
        let out = interpret_script(src).unwrap();
        assert_eq!(out, vec!["3", "c=3"]);
    }

    #[test]
    fn list_commands() {
        let src = r#"
            list types
            list type testobj
        "#;
        let out = interpret_script(src).unwrap();
        assert!(out.len() >= 2);
    }

    #[test]
    fn math_ops_and_pow_mod() {
        let src = r#"
            let a=2**3
            let b=7%3
            print a
            print b
        "#;
        let out = interpret_script(src).unwrap();
        assert_eq!(out, vec!["8", "1"]);
    }

    #[test]
    fn function_and_run_list() {
        let src = r#"
            let dd(x,y)=x+y
            let a=3
            let b=4
            run (dd,a,b)
        "#;
        let out = interpret_script(src).unwrap();
        assert_eq!(out, vec!["7"]);
    }

    #[test]
    fn custom_operator_registration_and_use() {
        let src = r#"
            let add2(x,y)=x+y
            reg operator <plus> add2
            let r=1 <plus> 2
            print r
        "#;
        let out = interpret_script(src).unwrap();
        assert_eq!(out, vec!["3"]);
    }

    #[test]
    fn pow_right_associative() {
        let src = r#"
            let a=2**3**2
            print a
        "#;
        let out = interpret_script(src).unwrap();
        assert_eq!(out, vec!["512"]);
    }

    #[test]
    fn custom_operator_precedence_with_mul() {
        let src = r#"
            let add2(x,y)=x+y
            reg operator <plus> add2
            let r=1 <plus> 2*3
            print r
        "#;
        let out = interpret_script(src).unwrap();
        assert_eq!(out, vec!["7"]);
    }

    #[test]
    fn print_template_no_arg() {
        let src = r#"
            print "hello"
        "#;
        let out = interpret_script(src).unwrap();
        assert_eq!(out, vec!["hello"]);
    }

    #[test]
    fn negative_exponent_error() {
        let src = r#"
            let a=2**-1
            print a
        "#;
        let err = interpret_script(src).unwrap_err();
        match err {
            super::ScriptError::RuntimeError(msg) => assert!(msg.contains("negative exponent")),
            _ => panic!("expected runtime error"),
        }
    }

    #[test]
    fn shell_transform_ident_to_print() {
        assert_eq!(shell_transform_line("abc"), "print abc\n");
        assert_eq!(shell_transform_line("  data_1  "), "print data_1\n");
        assert_eq!(shell_transform_line(":types"), "list types\n");
        assert_eq!(shell_transform_line(":type testobj"), "list type testobj\n");
    }

    #[test]
    fn shell_transform_expression_to_print() {
        assert_eq!(shell_transform_line("a+b"), "print a+b\n");
        assert_eq!(shell_transform_line("2**3"), "print 2**3\n");
        assert_eq!(shell_transform_line("(1 + 2) * 3"), "print (1 + 2) * 3\n");
    }

    #[test]
    fn sym_and_str_conversions() {
        let src = r#"
            print #"hello"
            print 'dd
        "#;
        let out = interpret_script(src).unwrap();
        assert_eq!(out, vec!["hello", "dd"]);
    }

    #[test]
    fn list_map_pipeline() {
        let src = r#"
            let id(x)=x
            print ((#"aa",#"bb",#"cc") |id)
        "#;
        let out = interpret_script(src).unwrap();
        assert_eq!(out, vec!["(aa bb cc)"]);
    }

    #[test]
    fn keyed_list_indexing_and_get() {
        let src = r#"
            let lst=(a=1,2,4)
            print lst["a"]
            print lst[0]
            print lst[1]
            get lst a
            get lst 'a
        "#;
        let out = interpret_script(src).unwrap();
        assert_eq!(out, vec!["1", "1", "2", "1", "1"]);
    }
    #[test]
    fn func_call_syntax_equivalent_to_run() {
        let src = r#"
            let add(x,y)=x+y
            print add(1,2)
            run (add,1,2)
        "#;
        let out = interpret_script(src).unwrap();
        assert_eq!(out, vec!["3", "3"]);
    }
    #[test]
    fn lisp_equivalence_features() {
        let src = std::fs::read_to_string("test_lisp.tbs").unwrap();
        let out = interpret_script(&src).unwrap();
        // Check expected outputs based on test_lisp.tbs content
        // 1. run (print "Hello Lisp") -> "Hello Lisp"
        assert_eq!(out[0], "Hello Lisp");
        // 2. run (print a b) -> "10", "20"
        assert_eq!(out[1], "10");
        assert_eq!(out[2], "20");
        // 3. run (print c) -> "(1 2 3)"
        assert_eq!(out[3], "(1 2 3)");
        // run (print d) -> "(4 5 6)"
        assert_eq!(out[4], "(4 5 6)");
        // 4. run (print (add 10 20)) -> "30"
        assert_eq!(out[5], "30");
        // run (print (add, 30, 40)) -> "70"
        assert_eq!(out[6], "70");
        // 5. run (print s1) -> "@mysym"
        assert_eq!(out[7], "@mysym");
        // run (print #s1) -> "mysym"
        assert_eq!(out[8], "mysym");
        // run (print #"directsym") -> "@directsym"
        assert_eq!(out[9], "@directsym");
        // run (print ##"directsym") -> "directsym"
        assert_eq!(out[10], "directsym");
        // 6. run (print s2) -> "@dynamic_sym"
        assert_eq!(out[11], "@dynamic_sym");
        // run (print #s2) -> "dynamic_sym"
        assert_eq!(out[12], "dynamic_sym");
        // 7. run (run (print "Nested Run")) -> "Nested Run"
        assert_eq!(out[13], "Nested Run");
        // 8. run (print e) -> "(1 2)"
        // Note: (a=1 b=2) creates a list with values 1, 2 and keys a, b.
        // to_string implementation for List just prints values space separated.
        assert_eq!(out[14], "(1 2)");
        // run (print f) -> "(10 20)"
        assert_eq!(out[15], "(10 20)");
        // 9. run (let g (add a b)) -> g = 10+20 = 30
        assert_eq!(out[16], "30");
    }
}
